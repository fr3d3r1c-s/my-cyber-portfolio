# TryHackMe: Filesystem Interaction Continued

**Date Completed:** September 14, 2025

## Introduction

This lab is a continuation of our journey into the Linux filesystem. The objective is to learn and practice a set of fundamental commands that allow us to create, move, and delete files and directories.

Specifically, this write-up covers the following commands:

Command	Full Name	Purpose
touch	touch	Create a file
mkdir	make directory	Create a folder
cp	copy	Copy a file or folder
mv	move	Move a file or folder
rm	remove	Remove a file or folder
file	file	Determine the type of a file


Creating Files and Folders (touch, mkdir)
Creating files and folders on Linux is a simple process. The touch command takes one argument: the name we want to give the file. It's important to note that touch creates a blank file, which you would need to edit later with a command like echo or a text editor like nano.

Creating a new file with touch
tryhackme@linux2:~$ touch note

tryhackme@linux2:~$ ls

Output:
folder1 note

The process is similar for making a directory. We use the mkdir command and provide the desired name.

Creating a new directory with mkdir
tryhackme@linux2:~$ mkdir mydirectory

tryhackme@linux2:~$ ls

Output:
folder1 mydirectory note

Removing Files and Folders (rm)
The rm command is used to remove files and folders.

To remove a file, simply use rm followed by the file name.

Using rm to remove a file
tryhackme@linux2:~$ rm note

tryhackme@linux2:~$ ls

Output:
folder1 mydirectory

To remove a directory, you must include the -R (recursive) switch alongside the rm command.

Using rm recursively to remove a directory
tryhackme@linux2:~$ rm -R mydirectory

tryhackme@linux2:~$ ls

Output:
folder1

Copying and Moving Files and Folders (cp, mv)
Copying Files with cp
The cp command takes two arguments: the name of the existing file and the name for the new copy. It copies the entire contents of the existing file into the new one.

Using cp to copy a file
tryhackme@linux2:~$ cp note note2

tryhackme@linux2:~$ ls

Output:
folder1 note note2

Moving and Renaming Files with mv
The mv command also takes two arguments. Rather than creating a copy, it moves or renames the file. The mv command can be used to move a file to a new folder or to rename it.

Using mv to move a file
tryhackme@linux2:~$ mv note2 note3

tryhackme@linux2:~$ ls

Output:
folder1 note note3

Determining File Type (file)
The file command is essential for confirming the true nature of a file, as file extensions (like .txt) can be misleading or nonexistent. This command takes one argument.

Using file to determine the contents of a file
tryhackme@linux2:~$ file note

Output:
note: ASCII text

Summary and Key Takeaways
This lab provided a practical walkthrough of core Linux filesystem commands. We learned that:

touch and mkdir are used for creating files and directories.

rm is used for removing files, and requires the -R switch for directories.

cp is for copying files, while mv is used for moving or renaming them.

file is a crucial command for identifying a file's type and contents.

This knowledge is fundamental for effective navigation and management of a Linux environment.


**Date Completed:** September 17, 2025


Linux Directory Fundamentals
This is a summary of key Linux directories and their functions, based on the TryHackMe "Linux Fundamentals" lab.

/etc
The /etc directory is a central location for system configuration files.

It stores essential system files used by the operating system.

Notable files include:

sudoers: Contains a list of users and groups with permission to run commands with sudo.

passwd and shadow: These files manage user passwords, storing them in an encrypted format (sha512).

/var
The /var directory, short for "variable," stores data that is frequently written or accessed by services and applications.

It's a main root folder on a Linux installation.

Commonly stores log files in /var/log.

Also stores other data not associated with a specific user, like databases.

/root
Unlike the /home directory, /root is the home directory for the "root" system user.

This is the default location for the root user's personal files and configuration settings.

/tmp
The /tmp directory is a temporary, volatile folder.

Its contents are cleared out when the computer is restarted, similar to how RAM works.

By default, any user can write to this folder, making it a useful location for storing temporary files or scripts in a pentesting context.

Key Takeaways
This module provided an introduction to key Linux concepts:

Connecting to a Linux machine using SSH.

Using command flags and switches (e.g., man pages).

Interacting with the filesystem and its contents.

Understanding file permissions and switching users.


**Date Completed:** September 18, 2025


File Transfer and Web Serving Utilities
I have successfully used several command-line tools and Python modules for file transfer and web serving. The following is a summary of the commands and their functions.

Downloading Files with wget
I learned how to download files from a remote server using the wget command. This command acts like a web browser, allowing for file retrieval over HTTP. The basic syntax is wget followed by the full URL of the file.

Command: wget https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt

Purpose: Downloads the file myfile.txt from the specified URL.

Secure File Transfer with scp
I used Secure Copy (scp) to securely transfer files between my local machine and a remote server. This utility uses the SSH protocol for authentication and encryption. The syntax is based on a SOURCE and DESTINATION model.

Copying from local to remote:

Command: scp important.txt ubuntu@192.168.1.30:/home/ubuntu/transferred.txt

Purpose: Transfers important.txt from the current directory to the remote server at 192.168.1.30, saving it as transferred.txt in the user's home directory.

Copying from remote to local:

Command: scp ubuntu@192.168.1.30:/home/ubuntu/documents.txt notes.txt

Purpose: Retrieves documents.txt from the remote server and saves it as notes.txt in the current directory.

Serving Files with Python's HTTPServer
I set up a quick and easy web server using Python 3's built-in HTTPServer module. This is useful for sharing files from a specific directory. The server listens on a specified port, allowing other machines to download files from it.

Starting the server:

Command: python3 -m http.server

Purpose: Starts a web server in the current directory on port 8000.

Downloading from the server using wget:

Command: wget http://10.10.250.201:8000/.flag.txt

Purpose: Downloads the file .flag.txt from the Python server running on the remote machine at 10.10.250.201 on port 8000. The contents of the downloaded file are THM{HTTP_SERVER_SERVING_FILES}.

Next Steps
Explore advanced features of Python's HTTPServer by consulting its manual pages.

Practice creating and downloading various file types to reinforce the learning.

Investigate Updog as a more robust alternative to the simple Python server.

Remember to use Ctrl + C to stop the Python web server once finished.



**Date Completed:** September 20, 2025



Processes 101
Processes are the programs that are running on your machine. They're managed by the kernel, and each one has a unique identifier called a PID (Process ID). PIDs are assigned sequentially, so a new process will have a PID that's one greater than the last one started. For example, if the previous process had a PID of 300, the new one will have a PID of 301.

Viewing Processes
You can view a list of running processes with the ps command. This provides a one-time snapshot of the processes associated with your current user session, along with information like the process status, CPU usage time, and command name.

To see processes from all users and system processes, use ps aux.

For a real-time, constantly updating view of processes and system statistics, the top command is very useful. It refreshes every 10 seconds and shows you the most resource-intensive processes.

Managing Processes
You can send signals to processes to manage their state. The kill command is used for this, followed by the PID of the process you want to affect. For example, kill 1337 would terminate the process with PID 1337.

Here are some common signals:

SIGTERM: Gracefully terminates a process, allowing it to perform cleanup tasks before exiting. This is the cleanest way to kill a process.

SIGKILL: Forcefully terminates a process immediately, without any cleanup.

SIGSTOP: Suspends a process.

How Processes Start
The OS uses namespaces to isolate processes from one another and manage resource allocation (like CPU and RAM).  Each namespace is like a "slice" of the computer's resources, and processes within that slice can't see or interact with those in other slices. This is a key security feature.

When a system boots, the first process to start is the init process, which has a PID of 0. On Ubuntu systems, this is systemd. All other user-started programs and services are launched as child processes of systemd. This relationship simplifies process management for the user and the OS.

Getting Processes/Services to Start on Boot
System services like web servers or databases often need to start automatically when the system boots. The systemctl command is used to interact with the systemd process to manage these services.

The basic format is systemctl [option] [service]. You can use it to:

start: Manually start a service.

stop: Manually stop a service.

enable: Configure a service to start on boot.

disable: Configure a service to not start on boot.

For example, to start the Apache web server, you'd use systemctl start apache2. To make it start on boot, you'd use systemctl enable apache2.

An Introduction to Backgrounding and Foregrounding
Processes can run in one of two states: in the foreground or in the background.

Foreground: A process that runs directly in your terminal, blocking it until the process completes.

Background: A process that runs independently of your terminal, freeing it up for other commands.

You can launch a command in the background by adding an ampersand (&) to the end of the command. For example, copy large_file &. This is great for long-running tasks like file transfers because you can continue using the terminal without waiting for the task to finish.

You can also move a running foreground process to the background by pressing Ctrl + Z. This suspends the process and returns control of the terminal to you.

To bring a backgrounded process back to the foreground and resume its execution, use the fg command.


**Date Completed:** September 24, 2025


A Guide to Cron and Apt
This entry provides a comprehensive overview of how to manage scheduled tasks with cron and software packages with apt on a Linux system, based on the provided material.

Understanding Cron and Crontabs
The cron process is a core component of Linux that is responsible for executing scheduled tasks, also known as cron jobs. These jobs are defined within a special file called a crontab. The cron process starts during system boot and runs continuously, checking the crontabs for tasks to perform.

A crontab entry has six specific values that define when and what an action is executed:

Value	Description
MIN	The minute to execute at
HOUR	The hour to execute at
DOM	The day of the month to execute at
MON	The month of the year to execute at
DOW	The day of the week to execute at
CMD	The command to be executed


The formatting can be simple, such as using an asterisk (*) as a wildcard for fields where the value doesn't matter.

Example:
To back up the "Documents" folder of a user named "cmnatic" every 12 hours, you would use the following format:
0 */12 * * * cp -R /home/cmnatic/Documents /var/backups/

You can edit your crontab by using the command crontab -e and selecting a text editor like Nano.

Managing Software with Apt and Repositories
Software for a Linux system is often stored in apt repositories. These are central locations where developers can submit their programs for community use. The apt command is a powerful tool used to manage these packages.

The integrity of the software you download is ensured by GPG (Gnu Privacy Guard) keys. Your system trusts these keys, and if a package's key doesn't match, the software will not be installed.

Adding a Repository Manually
Although you can use the add-apt-repository command, you can also manually add a repository by following these steps:

Add the GPG key to your trusted list.

Create a new file with a .list extension in the /etc/apt/sources.list.d directory.

Add the repository information to this new file.

Run apt update to make your system aware of the new repository.

Install the new software using apt install [software-name].

Removing a Repository
To remove a repository, you can either use the add-apt-repository --remove command or simply delete the .list file you created. After removing the repository file, you can uninstall the software using apt remove [software-name].

System Logging
System logs are located in the /var/log directory and contain important information about the applications and services running on your machine. These logs, which are automatically managed, are crucial for monitoring system health and investigating issues. For instance, web servers like Apache2 use an access log to record every user request and an error log to store information about any problems.
